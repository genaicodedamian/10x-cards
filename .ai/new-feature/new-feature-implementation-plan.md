# Plan Wdrożenia Funkcjonalności: Generuj fiszki do nauki języka
# WERSJA 2.0 - ULTRA-PRECYZYJNY PLAN PO IMPLEMENTACJI

## 1. Przegląd Funkcjonalności

Funkcjonalność "Generuj fiszki do nauki języka" umożliwia użytkownikom automatyczne generowanie zestawów 30 fiszek językowych przy użyciu sztucznej inteligencji. Użytkownik podaje tematykę (1-40 znaków) oraz wybiera języki dla awersu i rewersu fiszki z listy dostępnych opcji (polski, angielski, niemiecki, francuski). System generuje unikalne słowa/zwroty powiązane z tematyką, gdzie na każdej stronie fiszki znajduje się to samo słowo w wybranym języku.

**🚨 KRYTYCZNE RÓŻNICE od standardowej AI:**
- **Input**: Krótka tematyka + 2 języki (nie długi tekst)
- **Validation**: topic 1-40 chars (nie 1000-10000 chars)
- **API**: Nowy endpoint (nie reuse istniejącego)
- **Payload conflicts**: Metadane mają inne strukturę (topic vs source_text)
- **UI Components**: Wymagane Select (nie DropdownMenu)
- **Middleware**: Wymaga update protected paths

Wartość biznesowa polega na uproszczeniu procesu tworzenia materiałów do nauki języków obcych oraz zwiększeniu efektywności nauki poprzez spersonalizowane zestawy słownictwa tematycznego.

## 2. Specyfikacja Backend (API Endpoint)

### Endpoint Configuration
- **Metoda HTTP**: POST
- **Struktura URL**: `/api/ai/generate-language-flashcards`
- **Authentication**: Required (JWT Bearer token - obsługiwane przez middleware)

### **🚨 KRYTYCZNE**: Wymagane DTOs i Command Modele

**Lokalizacja**: `src/types.ts` - Dodać na koniec pliku przed sekcją "User Command Models & DTOs"

```typescript
//-----------------------------------------------------------------------------
// Language Learning Command Models & DTOs
//-----------------------------------------------------------------------------

/**
 * Defines the supported language codes for language learning flashcards.
 * Based on the language learning feature plan.
 */
export type LanguageCode = "polish" | "english" | "german" | "french";

/**
 * Command model for requesting language learning flashcard generation.
 * API: POST /api/ai/generate-language-flashcards
 * This is an action trigger for language-specific flashcard generation.
 */
export interface AIGenerateLanguageFlashcardsCommand {
  topic: string; // 1-40 characters
  front_language: LanguageCode;
  back_language: LanguageCode;
}

/**
 * Represents a single language flashcard suggestion generated by the AI.
 * Part of the AIGenerateLanguageFlashcardsResponseDto.
 * Contains word/phrase in front_language and its translation in back_language.
 */
export interface LanguageFlashcardSuggestionDto {
  front: string; // Word/phrase in front_language
  back: string; // Same word/phrase in back_language
  validation_status: ValidationStatus;
  validation_message?: string;
}

/**
 * Represents metadata associated with a language learning AI flashcard generation request.
 * Part of the AIGenerateLanguageFlashcardsResponseDto.
 */
export interface LanguageAIGenerationMetadataDto {
  topic_hash: string; // SHA-256 of topic
  topic_length: number;
  generation_duration_ms: number;
  model_used: string;
  front_language: LanguageCode;
  back_language: LanguageCode;
  truncated_count: number;
  rejected_count: number;
  total_suggestions: number;
}

/**
 * DTO for the response of a language learning AI flashcard generation request.
 * API: POST /api/ai/generate-language-flashcards
 */
export interface AIGenerateLanguageFlashcardsResponseDto {
  suggestions: LanguageFlashcardSuggestionDto[];
  metadata: LanguageAIGenerationMetadataDto;
}
```

### **🚨 KRYTYCZNE**: Zod Validation Schema

**Lokalizacja**: `src/pages/api/ai/generate-language-flashcards.ts`

```typescript
// Walidacja żądania
const LanguageFlashcardsCommandSchema = z.object({
  topic: z
    .string()
    .min(1, { message: "Topic is required." })
    .max(40, { message: "Topic must be at most 40 characters long." }),
  front_language: z.enum(["polish", "english", "german", "french"], {
    required_error: "Front language is required.",
    invalid_type_error: "Invalid front language selected."
  }),
  back_language: z.enum(["polish", "english", "german", "french"], {
    required_error: "Back language is required.", 
    invalid_type_error: "Invalid back language selected."
  })
});
```

### Szczegóły żądania
```json
{
  "topic": "Podróżowanie",
  "front_language": "english",
  "back_language": "polish"
}
```

### Szczegóły odpowiedzi
- **Status 200**: Successful generation
- **Status 400**: Invalid input (topic length, invalid languages)
- **Status 401**: Unauthorized
- **Status 429**: Rate limit exceeded
- **Status 500**: AI service failure
- **Status 503**: AI service unavailable

```json
{
  "suggestions": [
    {
      "front": "airplane",
      "back": "samolot",
      "validation_status": "valid",
      "validation_message": null
    }
  ],
  "metadata": {
    "topic_hash": "abc123...",
    "topic_length": 12,
    "generation_duration_ms": 2500,
    "model_used": "google/gemini-2.5-flash-lite-preview-06-17",
    "front_language": "english",
    "back_language": "polish",
    "truncated_count": 0,
    "rejected_count": 0,
    "total_suggestions": 30
  }
}
```

## 3. **🚨 KRYTYCZNE**: Specyfikacja Backend Service Layer

### languageFlashcardGenerationService.ts

**Lokalizacja**: `src/lib/services/languageFlashcardGenerationService.ts`

**KLUCZOWE RÓŻNICE od aiGenerationService:**
- **Model temperature**: 0.3 (nie 0.5) - dla consistent vocabulary
- **Max tokens**: 2000 (nie 1500) - dla 30 flashcards
- **Prompt structure**: Vocabulary generation (nie text analysis)
- **Hash input**: topic (nie source text)
- **Validation**: front/back word pairs (nie question/answer)

```typescript
import type { 
  AIGenerateLanguageFlashcardsResponseDto, 
  LanguageFlashcardSuggestionDto, 
  LanguageCode,
  ValidationStatus 
} from "../../types";
import { OpenRouterService } from "../openrouter/OpenRouterService";
import type { JsonSchema, Message } from "../openrouter/types";

// Helper for SHA-256 Hashing using Web Crypto API (compatible with Cloudflare Workers)
async function sha256(text: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

const LANGUAGE_FLASHCARD_SUGGESTION_SCHEMA: JsonSchema = {
  name: "language_flashcards",
  strict: true,
  schema: {
    type: "object",
    properties: {
      flashcards: {
        type: "array",
        items: {
          type: "object",
          properties: {
            front: { type: "string" },
            back: { type: "string" },
          },
          required: ["front", "back"],
          additionalProperties: false,
        },
      },
    },
    required: ["flashcards"],
    additionalProperties: false,
  },
};

// Language names mapping for AI prompts
const LANGUAGE_NAMES: Record<LanguageCode, string> = {
  polish: "Polish",
  english: "English", 
  german: "German",
  french: "French"
};

/**
 * Generates language learning flashcard suggestions based on the topic and language pair using OpenRouterService.
 * Creates exactly 30 unique vocabulary words/phrases for the given topic.
 */
export async function generateLanguageFlashcardSuggestions(
  topic: string,
  frontLanguage: LanguageCode,
  backLanguage: LanguageCode,
  userId: string,
  apiKey: string
): Promise<AIGenerateLanguageFlashcardsResponseDto> {
  const startTime = Date.now();

  console.log(`Generating language AI suggestions for user: ${userId}, topic: "${topic}", ${frontLanguage} -> ${backLanguage}`);

  // Create OpenRouterService instance with the provided API key
  const openRouterService = new OpenRouterService({ apiKey });

  const topic_length = topic.length;
  const topic_hash = await sha256(topic);

  const frontLangName = LANGUAGE_NAMES[frontLanguage];
  const backLangName = LANGUAGE_NAMES[backLanguage];

  const messages: Message[] = [
    {
      role: "system",
      content:
        "You are an expert language teacher that generates vocabulary flashcards for language learning. " +
        "Generate exactly 30 unique vocabulary words or phrases related to the specified topic. " +
        "Each flashcard must have a 'front' (word/phrase in the source language) and a 'back' (translation in the target language). " +
        "Focus on commonly used, practical vocabulary related to the topic. " +
        "Ensure all words are unique and relevant to the topic. " +
        "Return the suggestions as a JSON object matching the provided schema. Do not include any markdown or other formatting in the JSON response.",
    },
    {
      role: "user",
      content: `Generate exactly 30 unique vocabulary words/phrases for the topic: "${topic}".
Return each word/phrase in ${frontLangName} and its ${backLangName} translation.
Focus on commonly used, practical vocabulary related to this topic.
Ensure all words are unique and relevant to the topic.`,
    },
  ];

  let suggestionsFromAI: { front: string; back: string }[] = [];
  let modelUsed = "N/A";
  let llmError = null;

  try {
    const response = await openRouterService.getChatCompletion({
      messages,
      model: "google/gemini-2.5-flash-lite-preview-06-17", // Or choose a preferred model
      response_format: { type: "json_schema", json_schema: LANGUAGE_FLASHCARD_SUGGESTION_SCHEMA },
      temperature: 0.3, // Lower temperature for more consistent vocabulary
      max_tokens: 2000, // Higher token limit for 30 flashcards
    });

    modelUsed = response.model;
    if (response.choices && response.choices.length > 0 && response.choices[0].message.content) {
      const parsedContent = JSON.parse(response.choices[0].message.content);
      if (parsedContent.flashcards && Array.isArray(parsedContent.flashcards)) {
        suggestionsFromAI = parsedContent.flashcards;
      } else {
        console.error("AI response 'flashcards' field is missing or not an array:", parsedContent);
        llmError = "AI response format error: 'flashcards' field is missing or not an array.";
      }
    } else {
      console.error("AI response did not contain expected content:", response);
      llmError = "AI response did not contain expected content.";
    }
  } catch (error) {
    console.error("Error calling OpenRouterService:", error);
    llmError = error instanceof Error ? error.message : "Unknown error during AI generation.";
  }

  const processedSuggestions: LanguageFlashcardSuggestionDto[] = [];
  let truncated_count = 0;
  let rejected_count = 0;

  if (llmError) {
    // If there was a fundamental error with the LLM call, we might not have any suggestions.
  } else {
    suggestionsFromAI.forEach((rawSuggestion) => {
      let front = rawSuggestion.front;
      let back = rawSuggestion.back;
      let validation_status: ValidationStatus = "valid";
      let validation_message: string | undefined = undefined;

      if (!front || !back) {
        validation_status = "rejected";
        validation_message = "Missing front or back content.";
        rejected_count++;
      } else {
        // Clean up the content (remove extra whitespace, etc.)
        front = front.trim();
        back = back.trim();

        if (front.length > 200) {
          front = front.substring(0, 200);
          validation_status = "truncated";
          validation_message = (validation_message ? validation_message + " " : "") + "Front content truncated.";
          truncated_count++;
        }
        if (back.length > 500) {
          back = back.substring(0, 500);
          // If already truncated, append message, otherwise set status
          if (validation_status !== "truncated") {
            validation_status = "truncated";
            truncated_count++;
          }
          validation_message = (validation_message ? validation_message + " " : "") + "Back content truncated.";
        }
      }

      if (validation_status === "rejected") {
        processedSuggestions.push({
          front: front || "Rejected", // Provide placeholder if empty
          back: back || "Rejected", // Provide placeholder if empty
          validation_status,
          validation_message,
        });
      } else {
        processedSuggestions.push({
          front,
          back,
          validation_status,
          validation_message: validation_message || undefined, // Ensure it's undefined if no message
        });
      }
    });
  }

  const generation_duration_ms = Date.now() - startTime;

  return {
    suggestions: processedSuggestions,
    metadata: {
      topic_hash,
      topic_length,
      generation_duration_ms,
      model_used: modelUsed,
      front_language: frontLanguage,
      back_language: backLanguage,
      truncated_count,
      rejected_count,
      total_suggestions: processedSuggestions.length,
    },
  };
}
```

## 4. Specyfikacja Frontend (Widok i Interakcja)

### **🚨 KRYTYCZNE**: UI Components Dependencies

**PROBLEM Z DROPDOWNS**: DropdownMenu z shadcn/ui jest dla menu akcji, NIE dla form selectów!

**ROZWIĄZANIE**: Używać Select component z shadcn/ui

**WYMAGANE INSTALACJE**:
```bash
npx shadcn@latest add select
```

### **🚨 KRYTYCZNE**: Interfejsy Istniejących Komponentów

**EditFlashcardDialog props:**
```typescript
interface EditFlashcardDialogProps {
  isOpen: boolean;
  onClose: () => void;
  flashcard: FlashcardSuggestionItemVM | null;
  onSave: (updatedData: { id: string; front: string; back: string }) => void; // NIE (id, front, back)!
}
```

**SaveSetDialog props:**
```typescript
interface SaveSetDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (setName: string) => void;
  isSaving: boolean; // NIE isLoading!
  errorSaving: string | null; // NIE apiError!
  // BRAK defaultSetName prop!
}
```

### Kluczowe Komponenty UI

#### **LanguageSelector.tsx** - **🚨 KRYTYCZNA IMPLEMENTACJA**

**Lokalizacja**: `src/components/language-generator/LanguageSelector.tsx`

```typescript
import React from "react";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { LanguageCode } from "@/types";

interface LanguageOption {
  code: LanguageCode;
  label: string;
}

interface LanguageSelectorProps {
  label: string;
  selectedLanguage: LanguageCode | null;
  onLanguageChange: (language: LanguageCode) => void;
  languages: LanguageOption[];
  placeholder: string;
}

const LanguageSelector: React.FC<LanguageSelectorProps> = ({
  label,
  selectedLanguage,
  onLanguageChange,
  languages,
  placeholder,
}) => {
  return (
    <div className="grid w-full gap-1.5">
      <Label>{label}</Label>
      <Select
        value={selectedLanguage || ""}
        onValueChange={(value) => onLanguageChange(value as LanguageCode)}
      >
        <SelectTrigger className="w-full">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {languages.map((language) => (
            <SelectItem key={language.code} value={language.code}>
              {language.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default LanguageSelector;

// NIE używać DropdownMenu - to powoduje problemy z otwieraniem!
```

#### **LanguageTopicInput.tsx**

**Lokalizacja**: `src/components/language-generator/LanguageTopicInput.tsx`

```typescript
import React from "react";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";

interface LanguageTopicInputProps {
  topic: string;
  onTopicChange: (topic: string) => void;
  charCount: number;
  error: string | null;
  minLength: number;
  maxLength: number;
}

const LanguageTopicInput: React.FC<LanguageTopicInputProps> = ({
  topic,
  onTopicChange,
  charCount,
  error,
  minLength,
  maxLength,
}) => {
  const isInvalid = error !== null && topic.length > 0;
  const isOverLimit = charCount > maxLength;

  return (
    <div className="grid w-full gap-1.5">
      <Label htmlFor="topic-input">Tematyka</Label>
      <Input
        id="topic-input"
        type="text"
        placeholder="Np. Podróżowanie, Gotowanie, Biznes..."
        value={topic}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => onTopicChange(e.target.value)}
        className={isInvalid ? "border-red-500 focus-visible:ring-red-500" : ""}
        aria-describedby="topic-validation"
        maxLength={maxLength + 10} // Allow a bit over limit to show error
      />
      <div className="flex justify-between text-sm" id="topic-validation">
        {isOverLimit ? (
          <p className="text-red-500">
            Liczba znaków: {charCount} / {maxLength}
          </p>
        ) : (
          <p className={isInvalid ? "text-red-500" : "text-muted-foreground"}>
            {error ? error : `Liczba znaków: ${charCount} / ${maxLength}`}
          </p>
        )}
        {!isInvalid && !isOverLimit && topic.length > 0 && charCount >= minLength && charCount <= maxLength && (
          <p className="text-green-600">Wygląda dobrze!</p>
        )}
      </div>
    </div>
  );
};

export default LanguageTopicInput;
```

### **🚨 KRYTYCZNE**: View Model Structure

```typescript
// ROZSZERZENIE istniejącego LanguageFlashcardSuggestionDto
export interface LanguageFlashcardSuggestionItemVM extends LanguageFlashcardSuggestionDto {
  id: string; // crypto.randomUUID()
  isAccepted: boolean; // dla UI state
  currentFront: string; // editable version
  currentBack: string; // editable version  
  originalFront: string; // original from AI
  originalBack: string; // original from AI
}

// Available languages constant
const AVAILABLE_LANGUAGES = [
  { code: "polish" as LanguageCode, label: "Polski" },
  { code: "english" as LanguageCode, label: "Angielski" },
  { code: "german" as LanguageCode, label: "Niemiecki" },
  { code: "french" as LanguageCode, label: "Francuski" }
];
```

### **🚨 KRYTYCZNE**: Stan Management Requirements

**Lokalizacja**: `src/components/language-generator/LanguageFlashcardGenerator.tsx`

```typescript
import React, { useState, useEffect, useCallback, useMemo } from "react";
// ... wszystkie imports z absolute paths!

const LanguageFlashcardGenerator: React.FC = () => {
  // Form state
  const [topic, setTopic] = useState<string>("");
  const [frontLanguage, setFrontLanguage] = useState<LanguageCode | null>(null);
  const [backLanguage, setBackLanguage] = useState<LanguageCode | null>(null);
  
  // Validation state
  const [isTopicValid, setIsTopicValid] = useState<boolean>(false);
  const [charCount, setCharCount] = useState<number>(0);
  const [topicError, setTopicError] = useState<string | null>(null);
  const [languageError, setLanguageError] = useState<string | null>(null);
  
  // Generation state
  const [suggestions, setSuggestions] = useState<LanguageFlashcardSuggestionItemVM[]>([]);
  const [generationMetadata, setGenerationMetadata] = useState<LanguageAIGenerationMetadataDto | null>(null);
  const [isLoadingSuggestions, setIsLoadingSuggestions] = useState<boolean>(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  
  // UI state - reszta stanów...

  // PERFORMANCE OPTIMIZATIONS - WYMAGANE
  const isFormValid = useMemo(() => 
    isTopicValid && frontLanguage && backLanguage && !languageError,
    [isTopicValid, frontLanguage, backLanguage, languageError]
  );

  const acceptedCount = useMemo(() => 
    suggestions.filter((s) => s.isAccepted).length,
    [suggestions]
  );

  // DEBOUNCED VALIDATION - WYMAGANE
  useEffect(() => {
    const debounceTimeout = setTimeout(() => {
      const len = topic.length;
      setCharCount(len);
      if (len === 0) {
        setTopicError(null);
        setIsTopicValid(false);
      } else if (len < MIN_TOPIC_LENGTH) {
        setTopicError("Tematyka jest wymagana");
        setIsTopicValid(false);
      } else if (len > MAX_TOPIC_LENGTH) {
        setTopicError(`Tematyka może mieć maksymalnie ${MAX_TOPIC_LENGTH} znaków`);
        setIsTopicValid(false);
      } else {
        setTopicError(null);
        setIsTopicValid(true);
      }
    }, 300); // 300ms debounce

    return () => clearTimeout(debounceTimeout);
  }, [topic]);

  // Wszystkie handlery muszą być useCallback!
  const handleGenerateSuggestions = useCallback(async () => {
    // implementation
  }, [isFormValid, topic, frontLanguage, backLanguage]);

  const handleAcceptSuggestion = useCallback((id: string) => {
    // implementation
  }, []);

  // itd...
```

## 5. **🚨 KRYTYCZNE**: Middleware i Routing Updates

### Middleware Update - **OBOWIĄZKOWE**

**Lokalizacja**: `src/middleware/index.ts`

```typescript
// DODAĆ nową ścieżkę do PROTECTED_PATHS
const PROTECTED_PATHS = [
  "/dashboard",
  "/generate-ai",
  "/generate-language-flashcards", // <- DODAĆ TO!
  "/create-manual",
  "/my-flashcards",
  "/study-session",
];
```

### Dashboard Navigation Update

**Lokalizacja**: `src/pages/dashboard.astro`

```typescript
const navigationItems = [
  {
    title: "Generuj fiszki z AI",
    href: "/generate-ai",
    description: "Automatycznie twórz zestawy fiszek na podstawie Twoich materiałów.",
  },
  {
    title: "Generuj fiszki do nauki języka", // <- DODAĆ TO!
    href: "/generate-language-flashcards",
    description: "Twórz słownictwo tematyczne do nauki języków obcych.",
  },
  {
    title: "Stwórz fiszki manualnie",
    href: "/create-manual",
    description: "Pełna kontrola nad procesem tworzenia Twoich fiszek.",
  },
  {
    title: "Moje zestawy fiszek",
    href: "/my-flashcards",
    description: "Przeglądaj i zarządzaj swoimi kolekcjami fiszek.",
  },
];
```

### Astro Page

**Lokalizacja**: `src/pages/generate-language-flashcards.astro`

```astro
---
import Layout from "@/layouts/Layout.astro";
import LanguageFlashcardGenerator from "@/components/language-generator/LanguageFlashcardGenerator.tsx";
---

<Layout title="Generuj Fiszki do Nauki Języka">
  <div class="container mx-auto py-8 px-4">
    <LanguageFlashcardGenerator client:load />
  </div>
</Layout>
```

## 6. **🚨 KRYTYCZNE**: Payload Conflicts i Resolutions

### Problem z source_text_length validation

**KONFLIKT**: Endpoint `/api/flashcard-sets` wymaga:
```typescript
source_text_length: z.number().min(1000).max(10000).optional()
```

**ALE**: Funkcjonalność językowa ma topic_length: 1-40 znaków!

**ROZWIĄZANIE**: NIE wysyłać source_text_length dla języków

```typescript
// W LanguageFlashcardGenerator.tsx - handleSaveSet
const createSetCommand: CreateFlashcardSetCommand = {
  name: setName,
  ...(generationMetadata && {
    source_text_hash: generationMetadata.topic_hash,
    generation_duration_ms: generationMetadata.generation_duration_ms,
    // KRYTYCZNE: NIE dodawać source_text_length!
    // source_text_length: generationMetadata.topic_length, // <- BŁĄD powoduje 400!
  }),
};
```

## 7. Kompleksowy Przepływ Danych (End-to-End)

### Krok 1: Inicjalizacja widoku
1. Użytkownik przechodzi z Dashboard do `/generate-language-flashcards`
2. Komponent LanguageFlashcardGenerator ładuje się z pustym stanem
3. Wyświetla się formularz z polami: topic, front language, back language

### Krok 2: Wprowadzanie danych
1. Użytkownik wpisuje tematykę -> walidacja client-side (debounced 300ms, 1-40 znaków)
2. Wybiera języki z Select dropdown -> sprawdzenie czy oba pola wybrane
3. Przycisk "Generuj fiszki językowe" aktywuje się po spełnieniu walidacji

### Krok 3: Generowanie AI
1. Frontend wysyła POST do `/api/ai/generate-language-flashcards`
2. Backend waliduje dane wejściowe (Zod schema)
3. Service `languageFlashcardGenerationService` wywołuje OpenRouter API z promptem
4. AI odpowiada listą 30 słów w obu językach
5. Backend waliduje odpowiedź, zapisuje metadane, zwraca LanguageFlashcardSuggestionDto[]

### Krok 4: Wyświetlanie sugestii
1. Frontend otrzymuje response, parsuje sugestie
2. Konwertuje na LanguageFlashcardSuggestionItemVM z unikalnym ID i statusem isAccepted
3. Wyświetla w siatce 3-kolumnowej z opcjami accept/edit/reject (reuse FlashcardSuggestionGrid)

### Krok 5: Zarządzanie sugestiami  
1. Accept: oznacza fiszkę jako zaakceptowaną
2. Edit: otwiera modal z polami front/back, po zapisie oznacza jako zaakceptowaną
3. Reject: usuwa z listy po potwierdzeniu w AlertDialog

### Krok 6: Zapisywanie zestawu
1. User klika "Zapisz zaakceptowane" lub "Zapisz wszystkie"
2. Otwiera się SaveSetDialog 
3. Po potwierdzeniu:
   - POST `/api/flashcard-sets` (tworzy zestaw BEZ source_text_length!)
   - POST `/api/flashcard-sets/{id}/flashcards/batch-create` (dodaje fiszki)
4. Success -> czyszczenie formularza + redirect do dashboard z toast notification

## 8. **ULTRA-PRECYZYJNE ETAPY WDROŻENIA**

### **BACKEND IMPLEMENTATION (Kroki 1-4)**

#### **Krok 1**: Dodanie nowych typów do `src/types.ts`
**Szczegóły:**
- Dodać na koniec pliku, przed sekcją "User Command Models & DTOs"
- Dokładnie skopiować kod z sekcji 2 powyżej
- **Sprawdzenie**: `npm run type-check` - brak błędów

#### **Krok 2**: Implementacja `languageFlashcardGenerationService.ts`
**Lokalizacja**: `src/lib/services/languageFlashcardGenerationService.ts`
**Szczegóły:**
- Skopiować DOKŁADNIE kod z sekcji 3 powyżej
- **Model**: "google/gemini-2.5-flash-lite-preview-06-17"
- **Temperature**: 0.3
- **Max tokens**: 2000
- **Sprawdzenie**: Compilation bez błędów

#### **Krok 3**: Implementacja API endpoint
**Lokalizacja**: `src/pages/api/ai/generate-language-flashcards.ts`
**Szczegóły:**
- Wzorować na `/api/ai/generate-flashcards.ts`
- Użyć Zod schema z sekcji 2
- **Sprawdzenie**: Endpoint dostępny, returns 400/401 properly

#### **Krok 4**: Middleware update
**Lokalizacja**: `src/middleware/index.ts`
**Szczegóły:**
- Dodać `/generate-language-flashcards` do PROTECTED_PATHS
- **Sprawdzenie**: Unauthorized redirect działa

### **FRONTEND IMPLEMENTATION (Kroki 5-8)**

#### **Krok 5**: Instalacja Select component
```bash
npx shadcn@latest add select
```
**Sprawdzenie**: `src/components/ui/select.tsx` istnieje

#### **Krok 6**: LanguageSelector.tsx
**Lokalizacja**: `src/components/language-generator/LanguageSelector.tsx`
**Szczegóły:**
- Skopiować kod z sekcji 4
- Użyć Select components (NIE DropdownMenu!)
- **Sprawdzenie**: Dropdown otwiera się i zamyka

#### **Krok 7**: LanguageTopicInput.tsx  
**Lokalizacja**: `src/components/language-generator/LanguageTopicInput.tsx`
**Szczegóły:**
- Skopiować kod z sekcji 4
- **Sprawdzenie**: Validation działa real-time

#### **Krok 8**: LanguageFlashcardGenerator.tsx
**Lokalizacja**: `src/components/language-generator/LanguageFlashcardGenerator.tsx`
**Szczegóły:**
- Import components z absolute paths: `@/components/language-generator/`
- useState + useEffect + useCallback + useMemo
- Debounced validation (300ms)
- Memoized computed values
- Reuse: FlashcardSuggestionGrid, EditFlashcardDialog, SaveSetDialog
- **KRYTYCZNE**: Props interfaces jak w sekcji 4
- **KRYTYCZNE**: Payload bez source_text_length jak w sekcji 6
- **Sprawdzenie**: Full user flow działa

#### **Krok 9**: generate-language-flashcards.astro page
**Lokalizacja**: `src/pages/generate-language-flashcards.astro`
**Szczegóły**:
- Skopiować kod z sekcji 5
- **Sprawdzenie**: Strona loaduje się

### **INTEGRATION & TESTING (Kroki 10-12)**

#### **Krok 10**: Dashboard navigation
**Lokalizacja**: `src/pages/dashboard.astro`
**Szczegóły**: 
- Dodać navigationItem jak w sekcji 5
- **Sprawdzenie**: Link działa, prowadzi do nowej strony

#### **Krok 11**: End-to-End Testing
**Test cases:**
1. Dashboard → Language Generator (link działa)
2. Form validation (topic + languages wymagane)
3. API call (30 suggestions returned)
4. Suggestions UI (accept/edit/reject działa)
5. Save set (bez source_text_length!)
6. Redirect do Dashboard
**Sprawdzenie**: Complete user journey 100% działa

#### **Krok 12**: Performance & Error Handling
**Optymalizacje:**
- Debounced validation ✓
- Memoized callbacks ✓
- Error boundary dla API failures ✓
- Loading states ✓
- Toast notifications ✓

## 9. **DEBUGGING GUIDE - Typowe Problemy**

### Problem 1: Dropdowns nie otwierają się
**Przyczyna**: Używanie DropdownMenu zamiast Select
**Rozwiązanie**: Przepisać na Select component

### Problem 2: "source_text_length must be at least 1000"
**Przyczyna**: Wysyłanie topic_length jako source_text_length
**Rozwiązanie**: Usunąć source_text_length z payload (sekcja 6)

### Problem 3: "Cannot find module './LanguageTopicInput'"
**Przyczyna**: Relative imports nie działają
**Rozwiązanie**: Używać absolute paths: `@/components/language-generator/`

### Problem 4: EditFlashcardDialog props error
**Przyczyna**: Interface change w onSave callback
**Rozwiązanie**: onSave przyjmuje object {id, front, back}, nie 3 parametry

### Problem 5: SaveSetDialog props error
**Przyczyna**: Props names różnią się
**Rozwiązanie**: isSaving/errorSaving (nie isLoading/apiError)

### Problem 6: Middleware protection nie działa
**Przyczyna**: Brak ścieżki w PROTECTED_PATHS
**Rozwiązanie**: Dodać `/generate-language-flashcards` do middleware

## 10. **SUCCESS CRITERIA - CHECKLIST**

### ✅ Backend Requirements
- [ ] Types defined w src/types.ts (sekcja 2)
- [ ] Service implemented z proper AI prompt (sekcja 3)
- [ ] API endpoint responds correctly
- [ ] Middleware protects new route (sekcja 5)
- [ ] Error logging działa

### ✅ Frontend Requirements  
- [ ] Select component installed (`npx shadcn@latest add select`)
- [ ] LanguageSelector opens/closes properly
- [ ] Form validation działa (debounced 300ms)
- [ ] API integration działa
- [ ] Suggestions display działa (reuse FlashcardSuggestionGrid)
- [ ] Save flow działa (bez source_text_length!)

### ✅ Integration Requirements
- [ ] Dashboard navigation działa (sekcja 5)
- [ ] Complete user journey działa (sekcja 7)
- [ ] Performance optimized (memoization, debouncing)
- [ ] Error handling robust (sekcja 9)
- [ ] No linting errors

**FINAL CHECK**: Full user flow od Dashboard do successful save i redirect back - MUSI działać 100%!