# Database Schema Planning Output

## Recommendations

**1. Table `Users` (Uzytkownicy)**
   *(Managed by Supabase Auth, listed for completeness)*
    *   `id` (UUID, Primary Key) - User identifier.
    *   `email` (TEXT, Unique) - User's email address.
    *   `created_at` (TIMESTAMP WITH TIME ZONE) - Account creation date.
    *   *(Other fields added and managed by the Supabase Auth mechanism)*

**2. Table `FlashcardSets` (ZestawyFiszek)**
    *   `id` (UUID, Primary Key, default `gen_random_uuid()`) - Unique identifier for the flashcard set.
    *   `user_id` (UUID, Foreign Key to `auth.users(id)`, NOT NULL, ON DELETE CASCADE) - Identifier of the user who owns the set.
    *   `name` (TEXT, NOT NULL) - Name or topic of the flashcard set (e.g., "Product Management").
    *   `created_at` (TIMESTAMP WITH TIME ZONE, default `NOW()`) - Set creation date.
    *   `updated_at` (TIMESTAMP WITH TIME ZONE, default `NOW()`) - Set last modification date.
    *   `last_studied_at` (TIMESTAMP WITH TIME ZONE, NULL) - Date of the last study session with this set.
    *   **Constraint**: `UNIQUE (user_id, name)` - Ensures that each user has unique names for their flashcard sets.

**3. Table `Flashcards` (Fiszki)**
    *   `id` (UUID, Primary Key, default `gen_random_uuid()`) - Unique identifier for the flashcard.
    *   `set_id` (UUID, Foreign Key to `FlashcardSets(id)`, NOT NULL, ON DELETE CASCADE) - Identifier of the set to which the flashcard belongs.
    *   `user_id` (UUID, Foreign Key to `auth.users(id)`, NOT NULL, ON DELETE CASCADE) - Identifier of the user who owns the flashcard (for RLS simplification).
    *   `front` (TEXT, NOT NULL) - Content of the flashcard's front side (question).
    *   `back` (TEXT, NOT NULL) - Content of the flashcard's back side (answer).
    *   `source` (TEXT, NOT NULL, CHECK (`source` IN ('manual', 'ai_generated', 'ai_generated_modified'))) - Origin of the flashcard:
        *   'manual': Created manually by the user.
        *   'ai_generated': Generated by AI and accepted without modification.
        *   'ai_generated_modified': Generated by AI and then modified by the user.
    *   `srs_interval` (INTEGER, NOT NULL, default 0) - Review interval (in days) for the Spaced Repetition algorithm.
    *   `srs_repetitions` (INTEGER, NOT NULL, default 0) - Number of consecutive correct reviews.
    *   `srs_ease_factor` (NUMERIC(4,2), NOT NULL, default 2.5) - Ease factor for the SRS algorithm.
    *   `srs_due_date` (TIMESTAMP WITH TIME ZONE, NOT NULL, default `NOW()`) - Date of the next scheduled review.
    *   `created_at` (TIMESTAMP WITH TIME ZONE, default `NOW()`) - Flashcard creation date.
    *   `updated_at` (TIMESTAMP WITH TIME ZONE, default `NOW()`) - Flashcard last modification date.

**4. Inter-Table Relationships**
    *   `Users` (1) --- (*) `FlashcardSets` (Many): One user can own many flashcard sets.
    *   `Users` (1) --- (*) `Flashcards` (Many): One user can own many flashcards (for query and RLS simplification).
    *   `FlashcardSets` (1) --- (*) `Flashcards` (Many): One flashcard set can contain many flashcards.

**5. Indexing**
    *   **`FlashcardSets`**:
        *   Index on `user_id` (for fast queries of a user's sets).
        *   Unique composite index `(user_id, name)` (ensures uniqueness of set names per user and speeds up searches).
    *   **`Flashcards`**:
        *   Index on `set_id` (for fast access to flashcards within a given set).
        *   Index on `user_id` (for fast queries of a user's flashcards).
        *   Index on `srs_due_date` (crucial for efficiently selecting flashcards for study sessions).
        *   *Recommendation*: Consider a unique composite index on `(set_id, front, back)` to prevent the creation of identical flashcards (same front and back content) within the same set.

**6. Row Level Security (RLS)**
    *   **For table `FlashcardSets`**: RLS policy ensuring users can perform operations (SELECT, INSERT, UPDATE, DELETE) only on their own flashcard sets.
        *   `USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id)`
    *   **For table `Flashcards`**: RLS policy ensuring users can perform operations only on their own flashcards.
        *   `USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id)`

**7. Cascading Deletes**
    *   Foreign keys (`user_id` in `FlashcardSets` and `Flashcards`, and `set_id` in `Flashcards`) should have the `ON DELETE CASCADE` option defined. This means:
        *   Deleting a user from the system (`auth.users`) will automatically delete all their flashcard sets and all their individual flashcards.
        *   Deleting a flashcard set will automatically delete all flashcards belonging to that set.

**8. Helper Functions and Triggers (PostgreSQL)**
    *   It is recommended to implement a trigger (or use built-in Supabase mechanisms) that automatically updates the `updated_at` field to the current date and time (`NOW()`) upon each row modification in the `FlashcardSets` and `Flashcards` tables.
    *   Application logic will be responsible for updating the `FlashcardSets.last_studied_at` field after a user completes a study session using flashcards from that set.

**9. Data Types and Constraints**
    *   `UUID` for primary keys.
    *   `TEXT` for variable-length text fields (e.g., `name`, `front`, `back`).
    *   `TIMESTAMP WITH TIME ZONE` for all fields storing date and time.
    *   `INTEGER` for `srs_interval` and `srs_repetitions`.
    *   `NUMERIC(4,2)` for `srs_ease_factor` (e.g., stores values like 2.50).
    *   `NOT NULL` constraints for all fields that cannot be empty (e.g., foreign keys, flashcard `front` and `back`, set `name`).
    *   `CHECK` constraint for the `Flashcards.source` field limiting allowed values.